// Memóriaszivárgás detektor
struct LeakDetector {
    allocations: Map[*u8, AllocationInfo],
    stack_depth: usize,
    enabled: bool
}

struct AllocationMeta {
    size: usize,
    timestamp: u64,
    backtrace: [*u8; 16]
}

impl LeakDetector {
    fv track_allocation(ptr: *u8, size: usize) {
        if GLOBAL_DETECTOR.enabled {
            vált backtrace = capture_backtrace(GLOBAL_DETECTOR.stack_depth);
            GLOBAL_DETECTOR.allocations.insert(ptr, AllocationMeta {
                size,
                timestamp: get_nanotime(),
                backtrace
            });
        }
    }

    fv check_leaks() -> bool {
        vált mut leaks = false;
        szor (ptr, meta) in &GLOBAL_DETECTOR.allocations {
            eprintln!("LEAK: {} bytes at {:p}", meta.size, ptr);
            print_backtrace(meta.backtrace);
            leaks = true;
        }
        leaks
    }
}