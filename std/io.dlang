// FFI deklarációk
extern fv __print(ptr: *u8) -> void;
extern fv __println(ptr: *u8) -> void;
extern fv __read_line() -> *u8 // NEM *void, hanem *u8 a helyes visszatérési típus!!!
extern fv __free_string(ptr: *u8) -> void;
extern fv __format_string(fmt_ptr: *u8, args_ptr: *u8, args_count: usize) -> *u8;

// Dlangos burkoló függvények
fv print(s: str) -> void {
    var c_str = s.to_string(); // Konverzió C stringgé
    __print(c_str);
    __free_string(c_str);
}

fv println(s: str) -> void {
    var c_str = s.to_string();
    __println(c_str);
    __free_string(c_str);
}

fv read_line() -> str {
    var ptr = __read_line();
    ha ptr is null {
        return ""; // Hiba esetén üres string
    }
    var s = str::from_c_string(ptr); // Konverzió Dlang stringgé
    vissza s;
}

// Formázott kiírás alapfüggvények
fv printf(format: str, args:...) -> void {
    var arg_count = args.length;
    var arg_pointers = new byte*[arg_count]; // Fontos, hogy byte**, azaz *u8 legyen, pointertömböt kell átadni!
    szor i, arg in args {
        arg_pointers[i] = arg.to_formatted_string().to_c_str();
    }
    
    var formatted_ptr = __format_string(
        format.to_str(),
        arg_pointers.ptr,
        arg_count
    );
    
    ha formatted_ptr is null {
        eprintln!("Hiba a formázott string létrehozásakor!");
        // Fontos! - Ha valami gond volt, akkor is fel kell szabadítani az argumentumokat
        szor i in 0..arg_count {
            __free_string(arg_pointers[i]);
        }
        return;
    }
    
    var formatted = str::from_c_str(formatted_ptr);
    println(formatted); // A println már felszabadítja a memóriát, ahogy kell
    
    szor i in 0..arg_count {
        __free_string(arg_pointers[i]);
    }
    __free_string(formatted_ptr);
}

// Formázott string létrehozása - Ezt át kellett írni, hogy __format_string-et használja!
fv format_string(format: str, args:...) -> str {
    var arg_count = args.length;
    var arg_pointers = new byte*[arg_count]; // Fontos, hogy byte**, azaz *u8 legyen, pointertömböt kell átadni!
    szor i, arg in args {
        arg_pointers[i] = arg.to_formatted_string().to_c_str();
    }
    
    var formatted_ptr = __format_string(
        format.to_c_str(),
        arg_pointers.ptr,
        arg_count
    );
    
    ha formatted_ptr is null {
        eprintln("Hiba a formázott string létrehozásakor!");
        // Fontos! - Ha valami gond volt, akkor is fel kell szabadítani az argumentumokat
        szor i in 0..arg_count {
            __free_string(arg_pointers[i]);
        }
        return "";
    }
    
    var formatted = str::from_c_str(formatted_ptr);
    
    szor i in 0..arg_count {
        __free_string(arg_pointers[i]);
    }
    
    vissza formatted; // Fontos! NE szabadítsd fel a memóriát itt, hanem a hívó félnek kell!
}

fv apply_format_specifier(value: any, spec: str) -> str {
    match spec {
        "x" => format_as_hex(value),
        ".2f" => format_float_precision(value, 2),
        _ => value.to_formatted_string()
    }
}

// Segédfüggvények specifikus típusokhoz
fv format_i32(value: i32) -> str {
    vissza value.to_string();
}

fv format_f64(value: f64) -> str {
    vissza value.to_string();
}

fv format_bool(value: bool) -> str {
    vissza ha value { "igaz" } vagy { "hamis" };
}

// Automatikus típuskonverzió
trait Formattable {
    fv to_formatted_string(self) -> str;
}

impl Formattable for i32 {
    fv to_formatted_string(self) -> str {
        format_i32(self);
    }
}

impl Formattable for f64 {
    fv to_formatted_string(self) -> str {
        format_f64(self);
    }
}

impl Formattable for bool {
    fv to_formatted_string(self) -> str {
        format_bool(self);
    }
}